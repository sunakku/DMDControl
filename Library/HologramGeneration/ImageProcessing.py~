import math
import numpy as np
import scipy.ndimage as nd
import sys
from PIL import Image as pil
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def smoothing_fun(gratingphase,alpha,omega):
	return ( np.tanh(alpha*(gratingphase+omega))-np.tanh(alpha*(gratingphase-omega)))/2

'''
TargetImage object
load target image, apply fft2 and return fourier images of desired resolution
'''
class TargetImage(object):
        def __init__(self, **kwargs):
                self.image = kwargs.pop('image', None)
                self.targetshape = kwargs.pop('shape', (540,540))
		self.path =  kwargs.pop('path', None)
		self.fimage = np.zeros(self.targetshape)

		##gaussian width within [0,1] from zero to imagesize*2
		self.width = kwargs.pop('width', 1.0)
		self.FWHM = self.width*self.targetshape[0]*2.354
	def imagefft():
		if self.image == "gaus":
			self.fimage = IP.gaussian(targetshape,width)
		else:
			print "no function available for now"


'''
phasemap object
increase the resolution of measured phasemap by desired factors
return numpy array of size being (xsize*factor,ysize*factor)
where xsize,ysize = np.shape(Amp)
'''
class Phasemap(object):
        def __init__(self, **kwargs):
                self.method = kwargs.pop('method', None)
                self.Amp = kwargs.pop('Amp', np.zeros((9,9)))
                self.Phase = kwargs.pop('Phase', np.zeros((9,9)))
                self.Phase_res = kwargs.pop('Phase residual', np.zeros((9,9)))
                self.factor = kwargs.pop('factor', 30)
                self.phasemap_large = np.zeros((3,self.factor*np.shape(self.Amp)[0],self.factor*np.shape(self.Amp)[1] ))

	def interpolate(self):
                """                                                                  
                returns the interpolated image      
                """
		#upsample images
		fa=self.factor
		self.phasemap_large[0,fa/2::fa,fa/2::fa]=self.Amp
		self.phasemap_large[1,fa/2::fa,fa/2::fa]=self.Phase
		self.phasemap_large[2,fa/2::fa,fa/2::fa]=self.Phase_res
                self.phasemap_large = self.method(self.factor,self.phasemap_large)

	def interpolate_fft(self):
		ftAmp = np.fft.fft2(Amp)
		ftPhase = np.fft.fft2(Phase)
		ftphres = np.fft.fft2(Phase_res)
		self.phasemap_large = self.method(self.factor, ftAmp,ftPhase,ftphres)
'''
Hologram object
returns full DMD image (1920*1080) 
'''

class Hologram(object):
        def __init__(self, **kwargs):
                self.method = kwargs.pop('method', 'hologramize')
                self.factor = kwargs.pop('factor', 30)
                self.phasemap_large = kwargs.pop('phasemap',np.zeros((3,540,540)))
		self.resolution = kwargs.pop('resolution', (1080,1920))
		self.alpha = kwargs.pop('alpha', 4)
		self.hologram = np.zeros(self.resolution)
		self.im_shape = np.shape(self.phasemap_large)[1]
		self.X, self.Y = np.meshgrid(np.arange(self.im_shape)-self.im_shape/2,np.arange(self.im_shape)-self.im_shape/2)

	def compute_hologram(self):
		phasesum = np.round(np.mod(self.phasemap_large[1],2*math.pi)*12)
		self.hologram = self.method(self.X,self.Y,self.alpha,self.phasemap_large[0],phasesum,self.resolution)


############functions

##############################
#image loading and fourier transf.
##############################
def imload(path):
	return np.aray(pil.open(path))

def gaussian(shape,width):
	nx = np.arange(0,shape[0]) - shape[0]
	xx,yy = np.meshgrid(nx,nx)
	return 1*np.exp(-(xx**2+yy**2)/(2.*(width*shape[0]*2)**2))



##############################
#interpolation functions
##############################
#test data. gaussian phase map and intensity map
def gaus(factor,phasemap):
	width=0.2*np.shape(phasemap)[1]
	nx = np.arange(0,np.shape(phasemap)[1]) - np.shape(phasemap)[1]/2
	xx,yy = np.meshgrid(nx,nx)
	phasemap[0] = 1*np.exp(-(xx**2+yy**2)/(2.*width**2))
	phasemap[1] = 1*np.exp(-(xx**2+yy**2)/(2.*width**2))
	phasemap[2] = 0
	return phasemap

##using ndi convolve function
def linear_i(factor,phasemap):
	rect = np.zeros((factor*2,factor*2))
	rect[factor/2:3/2.*factor,factor/2:3/2.*factor] = 1
	kernel=nd.convolve(rect,rect)
	for i in np.arange(3):
		phasemap[i] = nd.convolve(phasemap[i],kernel)
	return phasemap

def sinc_i(factor,phasemap):
	'''
	under construction 1 nov 2016 @sunami
	'''
	rect = np.zeros((factor*2,factor*2))
	rect[factor/2:3/2.*factor,factor/2:3/2.*factor]=1
	kernel=nd.convolve(rect,rect,mode='wrap')
	for i in np.arange(3):
		phasemap[i] = nd.convolve(phasemap[i],kernel,mode='wrap')
	return phasemap


##using fourier plane convolution(simply multiply in fourier plane) for speed up
def zeropad(factor,ftAmp,ftPhase,ftphres):
	'''
	**under construction as of nov 1 2016 @sunami
	'''
	zp_phasemap = np.zeros((3,factor*np.shape(ftAmp)[0],factor*np.shape(ftAmp)[1] ))
	zp_phasemap[0] = np.fft.ifftw(Amp)	


##############################
#hologram functions
##############################
def hologramize(X,Y,alpha,amp,phasesum,resolution):
	dmdpattern = np.zeros(resolution)
	gratingphase = np.mod(Y+X+phasesum,12)
	omega = np.amin(amp)/amp
	hologram=1*( smoothing_fun(gratingphase,alpha,omega) < omega )
	Xsize,Ysize = np.shape(amp)
	dmdpattern[540-Xsize/2:540+Xsize/2,960-Ysize/2:960+Ysize/2]=hologram
	return dmdpattern
	
if __name__ == '__main__':
	print "test"






